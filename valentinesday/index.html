<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>For Annie | pqcnerd</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: radial-gradient(circle at top, #1e1b4b, #0f172a 55%, #020617 100%);
        --card-bg: rgba(15, 23, 42, 0.84);
        --border: rgba(148, 163, 184, 0.28);
        --text: #e2e8f0;
        --muted: #94a3b8;
        --accent: #f472b6;
        --accent-soft: rgba(244, 114, 182, 0.22);
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 1.25rem;
        background: var(--bg) fixed;
        color: var(--text);
        font-family: "Fira Code", "Cascadia Code", "SFMono-Regular", Menlo, Consolas,
          "Liberation Mono", monospace;
      }

      main {
        width: min(860px, 100%);
        background: var(--card-bg);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: clamp(1.25rem, 3vw, 2rem);
        box-shadow: 0 20px 60px rgba(2, 6, 23, 0.5);
        backdrop-filter: blur(10px);
        display: grid;
        gap: 1rem;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.35rem, 3.2vw, 2rem);
        color: var(--accent);
      }

      .intro {
        margin: 0;
        color: var(--muted);
        line-height: 1.6;
      }

      .controls {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .start-button {
        border-radius: 999px;
        border: 1px solid rgba(244, 114, 182, 0.55);
        background: var(--accent-soft);
        color: var(--accent);
        font-family: inherit;
        font-size: 0.95rem;
        font-weight: 600;
        padding: 0.52rem 1.1rem;
        cursor: pointer;
        transition: background 140ms ease, border-color 140ms ease, color 140ms ease;
      }

      .start-button:hover,
      .start-button:focus-visible {
        background: rgba(244, 114, 182, 0.33);
        border-color: rgba(244, 114, 182, 0.8);
        color: #fbcfe8;
        outline: none;
      }

      .start-button[disabled] {
        opacity: 0.65;
        cursor: default;
      }

      .status {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .poem {
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 12px;
        padding: clamp(1rem, 2.8vw, 1.3rem);
        background: rgba(15, 23, 42, 0.5);
        min-height: 320px;
        position: relative;
        overflow: hidden;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        overflow-anchor: none;
      }

      .poem > * {
        position: relative;
        z-index: 1;
      }

      .poem.choice-focus-active::after {
        content: "";
        position: absolute;
        inset: 0;
        z-index: 3;
        pointer-events: none;
        background: rgba(2, 6, 23, 0.76);
        -webkit-mask-image: radial-gradient(
          circle var(--choice-focus-radius, 240px) at var(--choice-focus-x, 50%) var(--choice-focus-y, 50%),
          transparent 0%,
          transparent 42%,
          black 82%
        );
        mask-image: radial-gradient(
          circle var(--choice-focus-radius, 240px) at var(--choice-focus-x, 50%) var(--choice-focus-y, 50%),
          transparent 0%,
          transparent 42%,
          black 82%
        );
      }

      .line {
        margin: 0;
        line-height: 1.9;
        white-space: pre-wrap;
        word-break: keep-all;
        overflow-wrap: normal;
        color: #d7e0ee;
      }

      .line.stanza-0 {
        color: #d7e0ee;
      }

      .line.stanza-1 {
        color: #dbeafe;
      }

      .line.stanza-2 {
        color: #d1fae5;
      }

      .line.stanza-3 {
        color: #f3e8ff;
      }

      .line.stanza-4 {
        color: #fee2e2;
      }

      .line.stanza-5 {
        color: #fef3c7;
      }

      .line + .line {
        margin-top: 0.2rem;
      }

      .line-spotlight {
        animation: lineGlow 760ms ease;
      }

      @keyframes lineGlow {
        0% {
          filter: brightness(1.18);
          text-shadow: 0 0 8px rgba(248, 250, 252, 0.22);
        }
        100% {
          filter: brightness(1);
          text-shadow: none;
        }
      }

      .typed-char {
        display: inline-block;
        animation: charPop 220ms cubic-bezier(0.2, 0.7, 0.2, 1) both;
        will-change: transform;
      }

      .typed-word {
        display: inline-block;
      }

      .emph-word {
        display: inline-block;
        will-change: filter, opacity, transform, text-shadow;
        position: relative;
        font-weight: 600;
      }

      .emph-flicker {
        animation: lampFlicker 2.8s steps(1, end) infinite;
        color: #fde68a;
      }

      .emph-glow {
        animation: softGlow 2.6s ease-in-out infinite alternate;
        color: #bae6fd;
      }

      .emph-twinkle {
        animation: starTwinkle 2.1s ease-in-out infinite;
        color: #fef08a;
      }

      .emph-pulse {
        animation: heartPulse 2.4s ease-in-out infinite;
        color: #f9a8d4;
      }

      .emph-word::after {
        position: absolute;
        right: -0.9em;
        top: -0.52em;
        font-size: 0.6em;
        line-height: 1;
        opacity: 0;
        pointer-events: none;
      }

      .emph-flicker::after {
        content: "\01F31F";
        animation: emojiSpark 1.9s ease-in-out infinite;
      }

      .emph-twinkle::after {
        content: "\2728";
        animation: emojiSpark 1.7s ease-in-out infinite;
      }

      .emph-glow::after {
        content: "\01F4AB";
        animation: emojiSpark 2s ease-in-out infinite;
      }

      .emph-pulse::after {
        content: "\01F495";
        animation: emojiSpark 2.2s ease-in-out infinite;
      }

      @keyframes lampFlicker {
        0%,
        18%,
        38%,
        62%,
        100% {
          filter: brightness(1);
          text-shadow: none;
        }
        9%,
        34%,
        58% {
          filter: brightness(1.16);
          text-shadow: 0 0 8px rgba(250, 204, 21, 0.26);
        }
      }

      @keyframes softGlow {
        0% {
          filter: brightness(1);
          text-shadow: 0 0 0 rgba(125, 211, 252, 0);
        }
        100% {
          filter: brightness(1.12);
          text-shadow: 0 0 10px rgba(125, 211, 252, 0.28);
        }
      }

      @keyframes starTwinkle {
        0%,
        100% {
          opacity: 0.94;
          transform: translateY(0);
          text-shadow: 0 0 0 rgba(255, 255, 255, 0);
        }
        50% {
          opacity: 1;
          transform: translateY(-0.01em);
          text-shadow: 0 0 10px rgba(253, 230, 138, 0.36);
        }
      }

      @keyframes heartPulse {
        0%,
        100% {
          transform: scale(1);
          filter: brightness(1);
        }
        45% {
          transform: scale(1.045);
          filter: brightness(1.15);
        }
      }

      @keyframes emojiSpark {
        0%,
        100% {
          opacity: 0;
          transform: translateY(0.2em) scale(0.85);
        }
        35%,
        65% {
          opacity: 0.88;
          transform: translateY(0) scale(1);
        }
      }

      @keyframes charPop {
        0% {
          transform: scale(0.72);
          opacity: 0.55;
        }
        65% {
          transform: scale(1.22);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .line-gap {
        display: block;
        height: 0.95rem;
      }

      .line-removing {
        overflow: hidden;
        transition: height 140ms linear, margin 140ms linear, padding 140ms linear, opacity 180ms linear;
      }

      .line-removal-wrap {
        display: block;
        transition: transform 140ms linear;
        will-change: transform;
      }

      .chosen-fill {
        color: #fbcfe8;
        font-weight: 600;
      }

      .rainbow-text {
        background-image: linear-gradient(
          90deg,
          #ff4d4d,
          #ff9f43,
          #feca57,
          #2ed573,
          #1e90ff,
          #a55eea,
          #ff4d4d
        );
        background-size: 300% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: rainbowShift 2.8s linear infinite;
      }

      @keyframes rainbowShift {
        0% {
          background-position: 0% 50%;
        }
        100% {
          background-position: 100% 50%;
        }
      }

      .blank-panel {
        border: 1px dashed rgba(244, 114, 182, 0.45);
        border-radius: 12px;
        padding: 0.95rem;
        background: rgba(30, 41, 59, 0.42);
      }

      .blank-panel[hidden] {
        display: none;
      }

      .blank-title {
        margin: 0 0 0.7rem;
        color: var(--accent);
        font-size: 0.95rem;
      }

      .blank-options {
        display: grid;
        gap: 0.6rem;
      }

      .blank-option {
        width: 100%;
        text-align: left;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.32);
        background: rgba(15, 23, 42, 0.65);
        color: var(--text);
        font-family: inherit;
        font-size: 0.9rem;
        padding: 0.65rem 0.75rem;
        cursor: pointer;
        transition: border-color 140ms ease, box-shadow 140ms ease, background 140ms ease;
      }

      .blank-option:hover,
      .blank-option:focus-visible {
        border-color: rgba(244, 114, 182, 0.75);
        background: rgba(30, 41, 59, 0.8);
        box-shadow: 0 0 0 2px rgba(244, 114, 182, 0.22);
        outline: none;
      }

      .surprise {
        border: 1px solid rgba(244, 114, 182, 0.45);
        border-radius: 12px;
        padding: 1rem;
        background: rgba(30, 41, 59, 0.5);
      }

      .surprise[hidden] {
        display: none;
      }

      .surprise-title {
        margin: 0 0 0.45rem;
        color: #fbcfe8;
        font-size: 1rem;
      }

      .surprise-text {
        margin: 0;
        color: var(--muted);
        line-height: 1.6;
      }

      .full-poem-button {
        margin-top: 0.95rem;
        border-radius: 999px;
        border: 1px solid rgba(244, 114, 182, 0.6);
        background: rgba(244, 114, 182, 0.18);
        color: #fbcfe8;
        font-family: inherit;
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
        cursor: pointer;
      }

      .full-poem-button:hover,
      .full-poem-button:focus-visible {
        background: rgba(244, 114, 182, 0.3);
        outline: none;
      }

      .full-poem-button[disabled] {
        opacity: 0.7;
        cursor: default;
      }

      .rewrite-prefix {
        display: inline-block;
        transition: opacity 280ms ease, width 280ms ease, margin-right 280ms ease;
        white-space: nowrap;
      }

      .rewrite-word {
        position: relative;
        display: inline-block;
        white-space: nowrap;
        color: #fbcfe8;
      }

      .rewrite-original {
        display: inline-block;
        transition: opacity 300ms ease;
      }

      .rewrite-scribble {
        position: absolute;
        left: -0.06em;
        right: -0.06em;
        top: 54%;
        height: 0.16em;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(244, 114, 182, 0.45), rgba(244, 114, 182, 0.95));
        box-shadow: 0 0 10px rgba(244, 114, 182, 0.4);
        transform: scaleX(0);
        transform-origin: left center;
        opacity: 0;
      }

      .rewrite-replacement {
        position: absolute;
        left: 0;
        top: 1.05em;
        color: #fbcfe8;
        opacity: 0;
        transform: translateY(0.35em);
        transition: opacity 350ms ease, transform 350ms ease;
      }

      .surprise.rewrite-active .rewrite-prefix {
        opacity: 0;
        width: 0;
        margin-right: 0;
      }

      .surprise.rewrite-active .rewrite-original {
        opacity: 0.45;
      }

      .surprise.rewrite-active .rewrite-scribble {
        animation: scribbleDraw 540ms ease forwards;
        opacity: 1;
      }

      .surprise.rewrite-active .rewrite-replacement {
        opacity: 1;
        transform: translateY(0);
        transition-delay: 300ms;
      }

      @keyframes scribbleDraw {
        0% {
          transform: scaleX(0) rotate(-3deg);
        }
        35% {
          transform: scaleX(1.04) rotate(2deg);
        }
        100% {
          transform: scaleX(1) rotate(-1deg);
        }
      }

      .heart-burst {
        position: fixed;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
        z-index: 999;
      }

      .heart {
        position: absolute;
        bottom: -2rem;
        filter: drop-shadow(0 0 10px rgba(244, 114, 182, 0.65));
        animation-name: floatHeart;
        animation-timing-function: ease-out;
        animation-fill-mode: forwards;
      }

      @keyframes floatHeart {
        0% {
          transform: translate3d(0, 0, 0) scale(0.8);
          opacity: 0;
        }
        12% {
          opacity: 1;
        }
        100% {
          transform: translate3d(var(--drift-x, 0px), -115vh, 0) scale(var(--final-scale, 1.18));
          opacity: 0;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .typed-char,
        .line-spotlight,
        .heart,
        .rainbow-text,
        .emph-word,
        .emph-word::after,
        .surprise.rewrite-active .rewrite-scribble {
          animation: none !important;
          transition: none !important;
        }
      }

      @media (max-width: 640px) {
        body {
          display: block;
          min-height: 100dvh;
          padding: 0.75rem;
        }

        main {
          margin: 0 auto;
          padding: 1rem;
          gap: 0.85rem;
        }

        .poem {
          min-height: 260px;
        }
      }
    </style>
  </head>
  <body>
    <main aria-label="Valentines Day page for Annie">
      <h1>For Annie</h1>
      <p class="intro">
        A little poem that unfolds one line at a time.
      </p>

      <div class="controls">
        <button type="button" id="start-poem" class="start-button">Start</button>
        <p id="playback-status" class="status">Press Start when you are ready.</p>
      </div>

      <section id="poem" class="poem" aria-live="polite" aria-label="Poem output"></section>

      <section id="blank-panel" class="blank-panel" hidden aria-label="Blank options">
        <h2 class="blank-title">Fill the blank to continue</h2>
        <div id="blank-options" class="blank-options"></div>
      </section>

      <section id="surprise-panel" class="surprise" hidden aria-label="A surprise for Annie">
        <h2 class="surprise-title">You made it to the end.</h2>
        <p class="surprise-text" id="surprise-text">
          <span class="rewrite-prefix" id="rewrite-prefix">and </span>
          <span class="rewrite-word" id="rewrite-word">
            <span class="rewrite-original">the universe</span>
            <span class="rewrite-scribble" aria-hidden="true"></span>
            <span class="rewrite-replacement">and I, Mark</span>
          </span>
          said I love you because you are love.
        </p>
        <button type="button" id="show-full-poem" class="full-poem-button" hidden>
          Show Full Poem
        </button>
      </section>
    </main>
    <div id="heart-burst" class="heart-burst" aria-hidden="true"></div>

    <script>
      let CHAR_DELAY_MS = 26;
      let LINE_DELAY_MS = 300;
      const STANZA_CLASS_COUNT = 6;
      const MAX_VISIBLE_BLOCKS_DESKTOP = 16;
      const MAX_VISIBLE_BLOCKS_MOBILE = 2;
      const EMPHASIS_RULES = [
        { phrase: "lamplit desk", effect: "flicker" },
        { phrase: "your name", effect: "flicker" },
        { phrase: "midnight", effect: "flicker" },
        { phrase: "Hong Kong", effect: "glow" },
        { phrase: "harbor's shimmer", effect: "glow" },
        { phrase: "moon", effect: "glow" },
        { phrase: "goodnight", effect: "glow" },
        { phrase: "miss you", effect: "glow" },
        { phrase: "sunrise", effect: "glow" },
        { phrase: "laughter", effect: "glow" },
        { phrase: "home", effect: "glow" },
        { phrase: "north-star", effect: "twinkle" },
        { phrase: "galaxies", effect: "twinkle" },
        { phrase: "Valentine", effect: "twinkle" },
        { phrase: "heart", effect: "pulse" },
        { phrase: "love", effect: "pulse" },
      ];
      const EMPHASIS_MATCHERS = EMPHASIS_RULES.map((rule) => ({
        ...rule,
        phraseLower: rule.phrase.toLowerCase(),
      })).sort((a, b) => b.phrase.length - a.phrase.length);

      const poemSequence = [
        { type: "line", text: "Across my lamplit desk I lingered, half in wonder, half in worry," },
        { type: "line", text: "Measuring the miles like minutes, turning distance into story;" },
        { type: "line", text: "While the radiator whispered, while the Charles kept darkly fanning," },
        { type: "line", text: "Came a midnight thought--your name--like a bell too sweet for banning;" },
        { type: "line", text: "And my heart, that tried for reason, found its reasons turning cranny--" },
        {
          type: "blank",
          pre: "Till my silence learned to answer with the word that is ",
          post: ".",
          options: ["Annie", "dearest Annie", "my Annie"],
        },
        { type: "break" },
        {
          type: "line",
          text: "In Hong Kong you wear the harbor's shimmer; in Cambridge I keep my river's glimmer;",
        },
        { type: "line", text: "Two clocks, two skies, two mornings--yet our same moon keeps its station," },
        { type: "line", text: "Silver courier over oceans, faithful to our conversation." },
        { type: "line", text: "So the night becomes a bridge-work, not a wall that leaves me stranded;" },
        { type: "line", text: "And the map, that once felt cruel, feels--by loving you--expanded," },
        { type: "line", text: "For the world has one true north-star (let the planets curse and frown):" },
        {
          type: "blank",
          pre: "It is ",
          post: ".",
          options: ["Annie", "bright Annie", "beloved Annie"],
        },
        { type: "break" },
        {
          type: "line",
          text: "Screens glow soft like little altars; messages like prayers I'm sending,",
        },
        { type: "line", text: "Every \"goodnight\" crossed with sunrise, every \"miss you\" never ending;" },
        { type: "line", text: "When the hour grows sharp with quiet, when the dormers stop their singing," },
        { type: "line", text: "I can hear your laughter travel--through the wires--brightly ringing." },
        { type: "line", text: "And I learn that love is patient, not because it waits unmoving," },
        {
          type: "line",
          text: "But because it keeps on building while the days insist on proving--",
        },
        {
          type: "line",
          text: "Not by touch alone, but trust, and that brave, steady insistence:",
        },
        {
          type: "blank",
          pre: "You are ",
          post: ".",
          options: ["Annie", "steady Annie", "radiant Annie"],
        },
        { type: "break" },
        { type: "line", text: "Bring the pan; let eggs be velvet, let the rice be amber-glowing;" },
        { type: "line", text: "Let the ketchup write its little comet-scripts in playful flowing." },
        {
          type: "line",
          text: "Call it simple--no, call it sacred: comfort dressed in humble clothing,",
        },
        {
          type: "line",
          text: "Proof that joy is not a grand thing, but a warmth the heart is loathing--",
        },
        {
          type: "line",
          text: "Loathing life without its sweetness, and discovering, quite uncanny,",
        },
        {
          type: "blank",
          pre: "That \"home\" can fit in one small word: it is ",
          post: ".",
          options: ["Annie", "sweet Annie", "dear Annie"],
        },
        { type: "break" },
        {
          type: "line",
          text: "We will watch the galaxies fold and dance through streetlight rain,",
        },
        {
          type: "line",
          text: "We will stand where poets dare and learn what brave can claim;",
        },
        {
          type: "line",
          text: "We will mend what memory smudges, keep what matters, let go gently--",
        },
        {
          type: "line",
          text: "Like a little robot learning love, stubborn, bright, and oddly friendly.",
        },
        { type: "line", text: "And if the night grows loud with headlines, I will hold one truth, not many:" },
        {
          type: "blank",
          pre: "Tomorrow has a center, and it's ",
          post: ".",
          options: ["Annie", "always Annie", "forever Annie"],
        },
        { type: "break" },
        {
          type: "line",
          text: "So hear me, love, across the oceans, past the calendars and duty:",
        },
        { type: "line", text: "I don't want a passing chapter; I want decades made of beauty." },
        { type: "line", text: "Let the distance do its worst work--still my choice remains quite plain:" },
        { type: "line", text: "I will cross it, I will close it, I will take your hand again." },
        { type: "line", text: "And until that day arrives, let this vow stand bright and true:" },
        {
          type: "blank",
          pre: "Be my Valentine--now and ever--my ",
          post: ".",
          options: ["Annie"],
        },
      ];

      const startButton = document.getElementById("start-poem");
      const poemContainer = document.getElementById("poem");
      const blankPanel = document.getElementById("blank-panel");
      const blankOptions = document.getElementById("blank-options");
      const statusText = document.getElementById("playback-status");
      const surprisePanel = document.getElementById("surprise-panel");
      const heartBurst = document.getElementById("heart-burst");
      const showFullPoemButton = document.getElementById("show-full-poem");
      const renderedPoem = [];
      let rewriteStarted = false;
      let fullPoemMode = false;
      let lineRemovalInProgress = false;

      startButton.addEventListener("click", async () => {
        startButton.disabled = true;
        statusText.textContent = "Writing...";
        await renderPoem();
        statusText.textContent = "For Annie, with love.";
        celebrateFinale();
      });

      showFullPoemButton?.addEventListener("click", () => {
        renderFullPoem();
      });

      applyPlaybackTiming();
      window.addEventListener("resize", applyPlaybackTiming);

      function wait(ms) {
        return new Promise((resolve) => window.setTimeout(resolve, ms));
      }

      function applyPlaybackTiming() {
        const isMobile = isMobileViewport();
        CHAR_DELAY_MS = isMobile ? 42 : 26;
        LINE_DELAY_MS = isMobile ? 520 : 300;
      }

      function isMobileViewport() {
        return window.matchMedia("(max-width: 640px)").matches;
      }

      function splitRainbowSegments(text) {
        return text
          .split(/(Annie)/g)
          .filter(Boolean)
          .map((part) => ({
            text: part,
            isRainbow: part === "Annie",
          }));
      }

      function splitEmphasisSegments(text) {
        const lowerText = text.toLowerCase();
        const segments = [];
        let index = 0;

        while (index < text.length) {
          const matchedRule = EMPHASIS_MATCHERS.find((rule) =>
            lowerText.startsWith(rule.phraseLower, index),
          );

          if (!matchedRule) {
            let nextBoundary = text.length;
            for (const rule of EMPHASIS_MATCHERS) {
              const nextIndex = lowerText.indexOf(rule.phraseLower, index);
              if (nextIndex !== -1 && nextIndex < nextBoundary) {
                nextBoundary = nextIndex;
              }
            }

            segments.push({
              text: text.slice(index, nextBoundary),
              effect: null,
            });
            index = nextBoundary;
            continue;
          }

          segments.push({
            text: text.slice(index, index + matchedRule.phrase.length),
            effect: matchedRule.effect,
          });
          index += matchedRule.phrase.length;
        }

        return segments.filter((segment) => segment.text.length > 0);
      }

      function buildStyledSegments(text) {
        const styledSegments = [];
        const emphasisSegments = splitEmphasisSegments(text);
        emphasisSegments.forEach((segment) => {
          const rainbowSegments = splitRainbowSegments(segment.text);
          rainbowSegments.forEach((rainbowSegment) => {
            styledSegments.push({
              text: rainbowSegment.text,
              isRainbow: rainbowSegment.isRainbow,
              effect: rainbowSegment.isRainbow ? null : segment.effect,
            });
          });
        });
        return styledSegments;
      }

      function appendStyledText(target, text) {
        const segments = buildStyledSegments(text);
        segments.forEach((segment) => {
          if (!segment.text) {
            return;
          }

          if (segment.isRainbow) {
            const rainbowSpan = document.createElement("span");
            rainbowSpan.className = "rainbow-text";
            rainbowSpan.textContent = segment.text;
            target.append(rainbowSpan);
            return;
          }

          if (segment.effect) {
            const emphSpan = document.createElement("span");
            emphSpan.className = `emph-word emph-${segment.effect}`;
            emphSpan.textContent = segment.text;
            target.append(emphSpan);
            return;
          }

          target.append(document.createTextNode(segment.text));
        });
      }

      async function typeRichText(target, text) {
        const segments = buildStyledSegments(text);
        for (const segment of segments) {
          const chunks = segment.text.split(/(\s+)/);
          for (const chunk of chunks) {
            if (!chunk) {
              continue;
            }

            if (/^\s+$/.test(chunk)) {
              for (const spaceChar of chunk) {
                target.append(
                  document.createTextNode(spaceChar === " " ? "\u00A0" : spaceChar),
                );
                await wait(CHAR_DELAY_MS);
              }
              continue;
            }

            const wordSpan = document.createElement("span");
            if (segment.effect) {
              wordSpan.className = `typed-word emph-word emph-${segment.effect}`;
            } else {
              wordSpan.className = "typed-word";
            }
            target.append(wordSpan);

            for (const character of chunk) {
              const charSpan = document.createElement("span");
              charSpan.className = segment.isRainbow
                ? "typed-char rainbow-text"
                : "typed-char";
              charSpan.textContent = character;
              wordSpan.append(charSpan);
              await wait(CHAR_DELAY_MS);
            }
          }
        }
      }

      async function renderPoem() {
        let stanzaIndex = 0;
        for (const segment of poemSequence) {
          if (segment.type === "break") {
            const spacer = document.createElement("span");
            spacer.className = "line-gap";
            poemContainer.append(spacer);
            renderedPoem.push({ type: "break" });
            maybeTrimPoemWindow("break", "");
            stanzaIndex += 1;
            await wait(200);
            continue;
          }

          const line = document.createElement("p");
          line.className = `line stanza-${stanzaIndex % STANZA_CLASS_COUNT}`;
          poemContainer.append(line);
          spotlightLine(line);
          line.scrollIntoView({ block: "nearest", behavior: "auto" });

          if (segment.type === "line") {
            await typeRichText(line, segment.text);
            renderedPoem.push({
              type: "line",
              text: segment.text,
              stanza: stanzaIndex % STANZA_CLASS_COUNT,
            });
            maybeTrimPoemWindow("line", segment.text);
            await wait(LINE_DELAY_MS);
            continue;
          }

          if (segment.type === "blank") {
            await typeRichText(line, segment.pre);
            const selectedFill = await waitForBlankChoice(segment.options);
            const fill = document.createElement("span");
            fill.className = "chosen-fill";
            line.append(fill);
            appendStyledText(fill, selectedFill);
            await typeRichText(line, segment.post);
            renderedPoem.push({
              type: "line",
              text: `${segment.pre}${selectedFill}${segment.post}`,
              stanza: stanzaIndex % STANZA_CLASS_COUNT,
            });
            maybeTrimPoemWindow("blank", `${segment.pre}${selectedFill}${segment.post}`);
            await wait(LINE_DELAY_MS);
            if (isMobileViewport()) {
              await showChoiceSpotlight(fill);
              poemContainer.innerHTML = "";
              clearChoiceSpotlight();
            }
          }
        }
      }

      async function showChoiceSpotlight(targetElement) {
        if (!targetElement || !isMobileViewport()) {
          return;
        }

        const containerRect = poemContainer.getBoundingClientRect();
        const targetRect = targetElement.getBoundingClientRect();
        const focusX = targetRect.left - containerRect.left + targetRect.width / 2;
        const focusY = targetRect.top - containerRect.top + targetRect.height / 2;
        const radius = Math.max(220, containerRect.width * 0.62);

        poemContainer.style.setProperty("--choice-focus-x", `${focusX}px`);
        poemContainer.style.setProperty("--choice-focus-y", `${focusY}px`);
        poemContainer.style.setProperty("--choice-focus-radius", `${radius}px`);
        poemContainer.classList.add("choice-focus-active");
        await wait(780);
      }

      function clearChoiceSpotlight() {
        poemContainer.classList.remove("choice-focus-active");
        poemContainer.style.removeProperty("--choice-focus-x");
        poemContainer.style.removeProperty("--choice-focus-y");
        poemContainer.style.removeProperty("--choice-focus-radius");
      }

      function maybeTrimPoemWindow(segmentType, text) {
        void segmentType;
        void text;
        trimPoemWindow();
      }

      function spotlightLine(lineElement) {
        lineElement.classList.add("line-spotlight");
        window.setTimeout(() => {
          lineElement.classList.remove("line-spotlight");
        }, 800);
      }

      function trimPoemWindow() {
        if (fullPoemMode || lineRemovalInProgress) {
          return;
        }
        const visibleLimit = isMobileViewport()
          ? MAX_VISIBLE_BLOCKS_MOBILE
          : MAX_VISIBLE_BLOCKS_DESKTOP;
        const visibleBlocks = Array.from(poemContainer.children).filter(
          (node) => !node.classList.contains("line-removing"),
        );
        if (isMobileViewport()) {
          const lineBlocks = visibleBlocks.filter((node) =>
            node.classList.contains("line"),
          );
          const overflowLines = lineBlocks.length - visibleLimit;
          if (overflowLines <= 0) {
            return;
          }

          const node = lineBlocks[0];
          const previous = node.previousElementSibling;
          if (previous && previous.classList.contains("line-gap")) {
            previous.remove();
          }

          lineRemovalInProgress = true;
          animateNodeOutByWrappedLines(node).then(() => {
            node.remove();
            lineRemovalInProgress = false;
            trimPoemWindow();
          });
          return;
        }

        const overflow = visibleBlocks.length - visibleLimit;
        if (overflow <= 0) {
          return;
        }

        const node = visibleBlocks[0];
        lineRemovalInProgress = true;
        animateNodeOutByWrappedLines(node).then(() => {
          node.remove();
          lineRemovalInProgress = false;
          trimPoemWindow();
        });
      }

      function animateNodeOutByWrappedLines(node) {
        const computed = window.getComputedStyle(node);
        const originalHeight = node.getBoundingClientRect().height;
        if (!Number.isFinite(originalHeight) || originalHeight <= 0.5) {
          return Promise.resolve();
        }

        const marginTop = parseFloat(computed.marginTop) || 0;
        const marginBottom = parseFloat(computed.marginBottom) || 0;
        const paddingTop = parseFloat(computed.paddingTop) || 0;
        const paddingBottom = parseFloat(computed.paddingBottom) || 0;
        const lineHeightRaw = parseFloat(computed.lineHeight);
        const stepHeight = Number.isFinite(lineHeightRaw) && lineHeightRaw > 0
          ? Math.max(10, Math.round(lineHeightRaw))
          : Math.max(12, Math.round(originalHeight / 2));

        const wrapper = document.createElement("span");
        wrapper.className = "line-removal-wrap";
        while (node.firstChild) {
          wrapper.append(node.firstChild);
        }
        node.append(wrapper);

        node.style.height = `${originalHeight}px`;
        node.style.marginTop = `${marginTop}px`;
        node.style.marginBottom = `${marginBottom}px`;
        node.style.paddingTop = `${paddingTop}px`;
        node.style.paddingBottom = `${paddingBottom}px`;
        node.style.opacity = "1";
        node.classList.add("line-removing");

        let removedHeight = 0;
        return new Promise((resolve) => {
          const tick = () => {
            removedHeight = Math.min(originalHeight, removedHeight + stepHeight);
            const remaining = Math.max(0, originalHeight - removedHeight);
            const ratio = originalHeight > 0 ? remaining / originalHeight : 0;

            node.style.height = `${remaining}px`;
            node.style.marginTop = `${marginTop * ratio}px`;
            node.style.marginBottom = `${marginBottom * ratio}px`;
            node.style.paddingTop = `${paddingTop * ratio}px`;
            node.style.paddingBottom = `${paddingBottom * ratio}px`;
            node.style.opacity = `${Math.max(0, Math.min(1, ratio + 0.08))}`;
            wrapper.style.transform = `translateY(-${removedHeight}px)`;

            if (remaining <= 0.5) {
              resolve();
              return;
            }
            window.setTimeout(tick, 115);
          };

          window.setTimeout(tick, 20);
        });
      }

      function waitForBlankChoice(options) {
        blankOptions.innerHTML = "";
        blankPanel.hidden = false;
        statusText.textContent =
          options.length === 1
            ? "One final choice."
            : "Choose a line to fill the blank.";

        return new Promise((resolve) => {
          options.forEach((optionText) => {
            const option = document.createElement("button");
            option.type = "button";
            option.className = "blank-option";
            appendStyledText(option, optionText);
            option.addEventListener("click", () => {
              blankPanel.hidden = true;
              statusText.textContent = "Writing...";
              resolve(optionText);
            });
            blankOptions.append(option);
          });
        });
      }

      function celebrateFinale() {
        surprisePanel.hidden = false;
        showFullPoemButton.hidden = false;
        launchHearts(120);
        window.setTimeout(() => {
          runRewriteAnimation();
        }, 650);
      }

      function launchHearts(count) {
        for (let index = 0; index < count; index += 1) {
          window.setTimeout(() => {
            spawnHeart();
          }, index * 55);
        }
      }

      function spawnHeart() {
        const heart = document.createElement("span");
        heart.className = "heart";
        const emojis = ["\u2764\ufe0f", "\ud83d\udc95", "\ud83d\udc96", "\ud83d\udc97", "\ud83d\udc93", "\ud83d\udc98"];
        heart.textContent = emojis[Math.floor(Math.random() * emojis.length)];
        heart.style.left = `${Math.random() * 100}%`;
        heart.style.fontSize = `${0.85 + Math.random() * 1.45}rem`;
        heart.style.animationDuration = `${3.4 + Math.random() * 3.2}s`;
        heart.style.setProperty("--drift-x", `${-95 + Math.random() * 190}px`);
        heart.style.setProperty("--final-scale", `${1 + Math.random() * 0.55}`);
        heartBurst.append(heart);
        window.setTimeout(() => {
          heart.remove();
        }, 7200);
      }

      function runRewriteAnimation() {
        if (rewriteStarted || !surprisePanel) {
          return;
        }
        rewriteStarted = true;
        surprisePanel.classList.add("rewrite-active");
      }

      function renderFullPoem() {
        fullPoemMode = true;
        poemContainer.innerHTML = "";

        renderedPoem.forEach((entry) => {
          if (entry.type === "break") {
            const spacer = document.createElement("span");
            spacer.className = "line-gap";
            poemContainer.append(spacer);
            return;
          }
          const line = document.createElement("p");
          line.className = `line stanza-${entry.stanza ?? 0}`;
          appendStyledText(line, entry.text);
          poemContainer.append(line);
        });

        blankPanel.hidden = true;
        statusText.textContent = "Full poem displayed.";
        showFullPoemButton.disabled = true;
        showFullPoemButton.textContent = "Full Poem Displayed";
      }
    </script>
  </body>
</html>
